from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import TimeoutException, NoSuchElementException, WebDriverException
import os
import time
from datetime import datetime, timedelta
import subprocess
import sys

# Configuration
DAY = '27'
TARGET_HOURS = 19  # 7 PM
TARGET_MINUTES = 0
USERNAME = 'anthonadj'
PASSWORD = 'SorLouise2!'


class TennisCourtBooker:
    def __init__(self):
        self.driver = None
        self.wait = None

    def setup_chrome_driver(self):
        """Setup Chrome driver with proper macOS configuration"""
        print("üîß Setting up Chrome driver for macOS...")

        # Chrome options for better stability
        chrome_options = Options()
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-dev-shm-usage")
        chrome_options.add_argument("--disable-blink-features=AutomationControlled")
        chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
        chrome_options.add_experimental_option('useAutomationExtension', False)
        chrome_options.page_load_strategy = 'eager'

        # Try different ways to initialize ChromeDriver
        driver_paths = [
            # If ChromeDriver is in PATH
            None,
            # Common Homebrew installation
            '/opt/homebrew/bin/chromedriver',
            '/usr/local/bin/chromedriver',
            # User's Downloads (fix the .exe extension issue)
            '/Users/anthonadj/Downloads/chromedriver-mac-x64/chromedriver',
            # Current directory
            './chromedriver'
        ]

        for path in driver_paths:
            try:
                if path is None:
                    # Let Selenium find ChromeDriver automatically
                    self.driver = webdriver.Chrome(options=chrome_options)
                else:
                    if os.path.exists(path):
                        service = Service(executable_path=path)
                        self.driver = webdriver.Chrome(service=service, options=chrome_options)
                    else:
                        continue

                self.wait = WebDriverWait(self.driver, 10)
                print("‚úÖ Chrome driver initialized successfully")
                return True

            except WebDriverException as e:
                print(f"‚ö†Ô∏è Failed to initialize with path: {path or 'auto'}")
                continue

        print("‚ùå Could not initialize Chrome driver")
        print("üí° Try installing ChromeDriver with: brew install chromedriver")
        return False


    def safe_enter_data(self, xpath, text, timeout=10):
        """Safely enter data with better error handling"""
        try:
            element = self.wait.until(EC.visibility_of_element_located((By.XPATH, xpath)))
            element.clear()
            element.send_keys(text)
            return True
        except TimeoutException:
            print(f"‚ö†Ô∏è Timeout waiting for element: {xpath}")
            return False
        except Exception as e:
            print(f"‚ö†Ô∏è Error entering data: {e}")
            return False

    def safe_click(self, xpath, timeout=10):
        """Safely click element with better error handling"""
        try:
            element = self.wait.until(EC.element_to_be_clickable((By.XPATH, xpath)))
            element.click()
            return True
        except TimeoutException:
            print(f"‚ö†Ô∏è Timeout waiting for clickable element: {xpath}")
            return False
        except Exception as e:
            print(f"‚ö†Ô∏è Error clicking element: {e}")
            return False

    def safe_click_css(self, css_selector, timeout=10):
        """Safely click element by CSS selector"""
        try:
            element = self.wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, css_selector)))
            element.click()
            return True
        except TimeoutException:
            print(f"‚ö†Ô∏è Timeout waiting for CSS element: {css_selector}")
            return False
        except Exception as e:
            print(f"‚ö†Ô∏è Error clicking CSS element: {e}")
            return False

    def login(self):
        """Handle login process"""
        print("üîê Starting login process...")

        login_url = "https://clubspark.lta.org.uk/SouthwarkPark/Account/SignIn?returnUrl=https%3a%2f%2fclubspark.lta.org.uk%2fSouthwarkPark%2fBooking%2fBookByDate"

        try:
            self.driver.get(login_url)
            time.sleep(2)

            # Click login button
            if not self.safe_click('/html/body/div[3]/div[1]/div[2]/div[1]/div[2]/form/button'):
                return False

            time.sleep(1)

            # Enter username
            if not self.safe_enter_data('//*[@id="154:0"]', USERNAME):
                return False

            # Enter password and submit
            if not self.safe_enter_data('//*[@id="input-2"]', PASSWORD):
                return False

            # Submit login form
            password_field = self.driver.find_element(By.XPATH, '//*[@id="input-2"]')
            password_field.send_keys(Keys.RETURN)

            time.sleep(3)
            print("‚úÖ Login completed")
            return True

        except Exception as e:
            print(f"‚ùå Login failed: {e}")
            return False

    def select_date(self):
        """Select booking date"""
        print(f"üìÖ Selecting day: {DAY}")

        try:
            # Click date picker
            if not self.safe_click('//*[@id="book-by-date-view"]/div/div[1]/div/div[1]/button'):
                return False

            time.sleep(1)

            # Find and click the specific day
            dates = self.driver.find_elements(By.CSS_SELECTOR, 'td[data-handler="selectDay"]')
            for date_element in dates:
                if date_element.text == DAY:
                    date_element.click()
                    print("‚úÖ Date selected")
                    return True

            print(f"‚ùå Could not find day {DAY}")
            return False

        except Exception as e:
            print(f"‚ùå Date selection failed: {e}")
            return False

    def check_slot_duration(self):
        """Check if selected slot has 1-hour option"""
        try:
            time.sleep(2)

            select_element = self.driver.find_element(By.ID, "booking-duration")
            options = select_element.find_elements(By.TAG_NAME, "option")

            print(f"üìã Found {len(options)} duration option(s)")

            if len(options) == 1:
                print("‚è≠Ô∏è Only 30-minute slot available")
                return False

            print("‚úÖ Multiple duration options available - can book 1 hour")
            return True

        except Exception as e:
            print(f"‚ö†Ô∏è Could not check duration: {e}")
            return False

    def close_booking_modal(self):
        """Close booking modal to return to slot selection"""
        try:
            # Try ESC key first (most reliable)
            self.driver.find_element(By.TAG_NAME, "body").send_keys(Keys.ESCAPE)
            time.sleep(1)

            # Check if we're back to slot selection
            if self.driver.find_elements(By.CSS_SELECTOR, "a.book-interval.not-booked"):
                print("‚úÖ Modal closed with ESC key")
                return True

            # Try other close methods
            close_selectors = [
                ".close", ".modal-close", "[data-dismiss='modal']",
                "button[aria-label='Close']", ".btn-close"
            ]

            for selector in close_selectors:
                try:
                    element = self.driver.find_element(By.CSS_SELECTOR, selector)
                    element.click()
                    time.sleep(1)
                    if self.driver.find_elements(By.CSS_SELECTOR, "a.book-interval.not-booked"):
                        print("‚úÖ Modal closed")
                        return True
                except:
                    continue

            print("‚ö†Ô∏è Could not close modal")
            return False

        except Exception as e:
            print(f"‚ö†Ô∏è Error closing modal: {e}")
            return False

    def find_and_book_slot(self):
        """Main slot finding and booking logic"""
        print("üîç Starting slot search...")

        # Refresh page to ensure clean state
        self.driver.refresh()
        time.sleep(2)

        target_time_minutes = TARGET_HOURS * 60 + TARGET_MINUTES
        hour_str = f"{TARGET_HOURS:02d}:{TARGET_MINUTES:02d}"
        print(f"üéØ Looking for slot at {hour_str} ({target_time_minutes} minutes)")

        # Wait until 19:59 to start booking

        start_time = time.time()
        max_duration = 5 * 60  # 5 minutes
        attempt = 0

        while time.time() - start_time < max_duration:
            attempt += 1
            elapsed = int(time.time() - start_time)
            print(f"üîÑ Attempt {attempt} (elapsed: {elapsed}s)")

            try:
                # Get all available booking links
                booking_links = self.driver.find_elements(By.CSS_SELECTOR, "a.book-interval.not-booked")

                if not booking_links:
                    print("‚ö†Ô∏è No booking slots available")
                    time.sleep(1)
                    self.driver.refresh()
                    time.sleep(2)
                    continue

                # Find slots at target time
                target_slots = []
                for link in booking_links:
                    data_test_id = link.get_attribute('data-test-id') or ""
                    if '|' in data_test_id:
                        parts = data_test_id.split('|')
                        if len(parts) >= 3:
                            try:
                                slot_time = int(parts[2])
                                if slot_time == target_time_minutes:
                                    target_slots.append(link)
                            except ValueError:
                                continue

                print(f"üéØ Found {len(target_slots)} slot(s) at {hour_str}")

                # Try each target slot
                for i, slot in enumerate(target_slots):
                    print(f"üîç Checking slot {i + 1}/{len(target_slots)}")

                    try:
                        # Scroll to element and click
                        self.driver.execute_script("arguments[0].scrollIntoView(true);", slot)
                        time.sleep(0.5)
                        slot.click()

                        if self.check_slot_duration():
                            print("‚úÖ 1-hour slot confirmed! Proceeding with booking...")
                            return True
                        else:
                            print(f"‚è≠Ô∏è Slot {i + 1} is 30-minute only")
                            if not self.close_booking_modal():
                                print("‚ö†Ô∏è Modal close failed, refreshing...")
                                self.driver.refresh()
                                time.sleep(2)
                                break
                            time.sleep(1)

                    except Exception as e:
                        print(f"‚ö†Ô∏è Error with slot {i + 1}: {e}")
                        continue

                if target_slots:
                    print(f"‚ùå All {len(target_slots)} slots at {hour_str} are 30-minute only")

                # Refresh and try again
                remaining = max_duration - (time.time() - start_time)
                if remaining > 5:
                    print(f"üîÑ Refreshing... ({int(remaining)}s remaining)")
                    self.driver.refresh()
                    time.sleep(2)
                else:
                    break

            except Exception as e:
                print(f"‚ö†Ô∏è Search error: {e}")
                time.sleep(1)

        print(f"‚ùå No suitable slot found at {hour_str}")
        return False

    def complete_booking(self):
        """Complete the booking process"""
        print("üìù Completing booking...")

        try:
            # Select 1-hour duration
            if not self.safe_click('/html/body/div[8]/div/div/div/div[1]/form/div[1]/div[1]/div[2]/div/div/div/span'):
                return False

            time.sleep(1)

            # Select 1-hour option
            if not self.safe_click('/html/body/span/span/span[2]/ul/li[2]'):
                return False

            time.sleep(1)

            # Submit booking
            if not self.safe_click('//*[@id="submit-booking"]'):
                return False

            time.sleep(2)
            print("‚úÖ Booking submitted, proceeding to payment...")
            return True

        except Exception as e:
            print(f"‚ùå Booking completion failed: {e}")
            return False

    def proceed_to_payment(self):
        """Navigate to payment but stop before entering sensitive data"""
        print("üí≥ Proceeding to payment page...")

        try:
            # Click pay now
            if not self.safe_click('//*[@id="paynow"]'):
                return False

            time.sleep(3)

            print("‚ö†Ô∏è  PAYMENT PAGE REACHED")
            print("üõë STOPPING AUTOMATION FOR SECURITY")
            print("üí° Please complete payment manually in the browser")
            print("üîç The browser will remain open for you to complete the transaction")

            # Keep browser open
            input("Press Enter after completing payment manually...")
            return True

        except Exception as e:
            print(f"‚ùå Payment navigation failed: {e}")
            return False

    def run(self):
        """Main execution function"""
        print("üéæ Tennis Court Booking Bot Starting...")

        if not self.setup_chrome_driver():
            return False

        try:
            # Execute booking flow
            if not self.login():
                return False

            if not self.select_date():
                return False

            if not self.find_and_book_slot():
                return False

            if not self.complete_booking():
                return False

            # Stop at payment for security
            self.proceed_to_payment()

            print("‚úÖ Booking process completed!")
            return True

        except KeyboardInterrupt:
            print("\n‚ö†Ô∏è Process interrupted by user")
            return False
        except Exception as e:
            print(f"‚ùå Unexpected error: {e}")
            return False
        finally:
            print("üîí Keeping browser open for manual completion")
            # Don't quit driver automatically - let user complete payment

    def cleanup(self):
        """Clean up resources"""
        if self.driver:
            self.driver.quit()
            print("‚úÖ Browser closed")


def check_chromedriver_installation():
    """Check if ChromeDriver is properly installed"""
    print("üîç Checking ChromeDriver installation...")

    try:
        result = subprocess.run(['chromedriver', '--version'],
                                capture_output=True, text=True, timeout=5)
        if result.returncode == 0:
            print(f"‚úÖ ChromeDriver found: {result.stdout.strip()}")
            return True
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass

    print("‚ùå ChromeDriver not found in PATH")
    print("üí° Install with: brew install chromedriver")
    print("üí° Or download from: https://chromedriver.chromium.org/")
    return False


if __name__ == "__main__":
    # Check prerequisites
    check_chromedriver_installation()

    # Run the booking bot
    booker = TennisCourtBooker()
    try:
        success = booker.run()
        if success:
            print("üéâ Booking process completed successfully!")
        else:
            print("‚ùå Booking process failed")
    except KeyboardInterrupt:
        print("\nüëã Goodbye!")
    finally:
        # Only cleanup if user confirms
        response = input("Close browser? (y/N): ").lower()
        if response == 'y':
            booker.cleanup()
